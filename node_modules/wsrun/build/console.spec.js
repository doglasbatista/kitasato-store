"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("./console");
const ts_mockito_1 = require("ts-mockito");
function nextTick() {
    return new Promise(resolve => setImmediate(resolve));
}
describe('serialized console', () => {
    let console;
    let c;
    beforeEach(() => {
        console = ts_mockito_1.mock();
        c = new console_1.SerializedConsole(ts_mockito_1.instance(console));
    });
    it('should only output from the active console', () => {
        let c1 = c.create();
        let c2 = c.create();
        c1.log('hello 1');
        ts_mockito_1.verify(console.log('hello 1')).once();
        c2.log('hello 2');
        ts_mockito_1.verify(console.log('hello 2')).never();
        c1.log('hello 3');
        ts_mockito_1.verify(console.log('hello 3')).once();
        c2.log('hello 4');
        ts_mockito_1.verify(console.log('hello 4')).never();
    });
    it('should output the second console when the first is done', () => __awaiter(this, void 0, void 0, function* () {
        let c1 = c.create();
        let c2 = c.create();
        c1.log('hello 1');
        ts_mockito_1.verify(console.log('hello 1')).once();
        c2.log('hello 2');
        ts_mockito_1.verify(console.log('hello 2')).never();
        c.done(c1);
        yield nextTick();
        ts_mockito_1.verify(console.log('hello 2')).once();
        c2.log('hello 3');
        ts_mockito_1.verify(console.log('hello 3')).once();
    }));
    it('should output from all consoles when they are done in the wrong order', () => __awaiter(this, void 0, void 0, function* () {
        let c1 = c.create();
        let c2 = c.create();
        let c3 = c.create();
        c1.log('hello 1');
        ts_mockito_1.verify(console.log('hello 1')).once();
        c2.log('hello 2');
        ts_mockito_1.verify(console.log('hello 2')).never();
        c3.log('hello 3');
        ts_mockito_1.verify(console.log('hello 3')).never();
        c.done(c2);
        yield nextTick();
        ts_mockito_1.verify(console.log('hello 2')).never();
        ts_mockito_1.verify(console.log('hello 3')).never();
        c.done(c1);
        yield nextTick();
        ts_mockito_1.verify(console.log('hello 2')).once();
        ts_mockito_1.verify(console.log('hello 3')).once();
    }));
    it('should log from console created after the first one is done', () => __awaiter(this, void 0, void 0, function* () {
        let c1 = c.create();
        c1.log('hello 1');
        ts_mockito_1.verify(console.log('hello 1')).once();
        c.done(c1);
        yield nextTick();
        let c2 = c.create();
        c2.log('hello 2');
        ts_mockito_1.verify(console.log('hello 2')).once();
    }));
});
//# sourceMappingURL=console.spec.js.map